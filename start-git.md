# Работа с GIT.

### __Содукжание__:

- [](#);
- [](#);
- [](#);
- [](#);
- [](#);
- [](#);
- [](#);
- [](#);

***

<a id=""></a>
## Сделать папку репозиторием — `git init`

```bash
$ cd ~/dev/first-project # перешли в нужную папку

$ git init # создали репозиторий 
```

По умолчанию, в качестве имени для начальной ветви используется `master`. Это имя ветви по умолчанию -
ссылка: может быть изменена. Чтобы настроить начальное имя ветви для использования во всех
новых репозиториев, которые будут подавлять предупреждение (для негров `master` обидное слово):


```bash
$ git config --global init.defaultBranch <name>
```

Так как для негров `master` обидное слово, то сочуувствующие выбирают такие названия, как "main", "trunk" и "development". Только что созданная ветвь может быть переименована с помощью этой команды:

```bash
$ git branch -m <name>
```


<a id=""></a>
## «Разгитить» папку - `rm -rf .git`

```bash
$ cd <папка с репозиторием> # перешли в папку

$ rm -rf .git # удалили подпапку .git 
```

<a id=""></a>
## Проверить состояние репозитория — `git status`

<u>Команда git status выведет</u>:

- название текущей ветки: `On branch master или On branch main`;
- сообщение о том, что в репозитории ещё нет коммитов: `No commits yet`;
- сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать), нужно сначала это создать» — `nothing to commit (create/copy files - and use "git add" to track)`.

<a id=""></a>
## Подготовить файлы к сохранению — `git add`

```bash
# подготовили к сохранению все файлы в репозитории
$ git add --all 
# или
$ git add .
# или 1 файл
$ git add start-work.md
# проверили статус 
$ git status 
```

 > Команда `git add` не сохраняет содержимое файлов в репозитории. Само сохранение, или фиксацию состояния файлов, называют коммитом (от англ. `commit` — «совершать», «фиксировать»). «Сделать коммит» значит сохранить текущую версию файла. 
 > Если провести аналогию, команду `git add` можно сравнить с добавлением товаров в корзину в интернет-магазине, а коммит — с оформлением и оплатой заказа.

<a id=""></a>
 ## Выполнить коммит — `git commit`

 Сделать коммит можно командой `git commit` c ключом `-m` (от англ. message — «сообщение»), который присваивает коммиту сообщение.

 ```bash
 $ git commit -m "Мой первый коммит!" 
 ```

<a id=""></a>
 ## Просмотреть историю коммитов — `git log`

 _Обратите внимание_, что по умолчанию `git log` выводит коммиты в обратном хронологическом порядке — последние коммиты оказываются первыми сверху. В этом можно убедиться, если посмотреть на дату и время их создания.

<u>Разберём элементы, из которых состоит описание</u>:

- строка из цифр и латинских букв после слова commit — это хеш коммита;
- Author — имя автора и его электронная почта;
- Date — дата и время создания коммита;
- в конце находится сообщение коммита.

При вызове команды git log можно заметить надпись `(HEAD -> master)` после хеша одного из коммитов. Файл `HEAD` (англ. «голова», «головной») — один из служебных файлов папки `.git`. Он указывает на коммит, который сделан последним (то есть на самый новый).

При работе с Git указатель `HEAD` используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово `HEAD` — Git поймёт, что вы имели в виду последний коммит.

<a id=""></a>
## Хеш — основной идентификатор коммита
Git хранит таблицу соответствий хеш → информация о коммите. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.

При работе с Git хеши будут встречаться регулярно. Их можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.

<a id=""></a>
## Статусы файлов в Git

- `untracked` (англ. «неотслеживаемый»)  
  Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.

- `staged` (англ. «подготовленный»)  
  После выполнения команды `git add` файл попадает в staging area (от англ. area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии `staged`.
  В одном из предыдущих уроков мы сравнили коммит с фотографией. Можно развить эту аналогию и сказать, что команда `git add` добавляет персонажей (текущее содержимое файла или нескольких файлов) на сцену (англ. stage) для общей фотографии, а `git commit` делает снимок всей сцены целиком. 
  
- `tracked` (англ. «отслеживаемый») - это противоположность `untracked`. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью `git commit`, а также файлы, которые были добавлены в `staging area` командой `git add`. То есть все файлы, в которых Git так или иначе отслеживает изменения.

- `modified` (англ. «изменённый») означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

<a id=""></a>
### Про `staged` и `modified`:

Команда `git add` добавляет в `staging area` только текущее содержимое файла. Если вы, например, сделаете `git add file.txt`, а затем измените `file.txt`, то новое содержимое файла не будет находиться в `staging`.

Git сообщит об этом с помощью статуса `modified`: файл изменён относительно той версии, которая уже в `staging`. Чтобы добавить в `staging` последнюю версию, нужно выполнить `git add file.txt` **ещё раз**.

#### Подытожим:

- Статусом `untracked` помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность `tracked`, в который попадают все файлы, отслеживаемые Git.
- Файл переходит в статус `staged` после выполнения `git add`.
- Статус `modified` означает, что файл был изменён.
- Большинство файлов в проектах "*шагает*" по следующему циклу: `изменён` → `добавлен в список на коммит` → `закоммичен` → `изменён` → и так далее.

<a id=""></a>
## Как читать `git status`

Большинство файлов в типичном проекте будут находиться в состоянии `tracked` (то есть закоммичены и не изменены после коммита). Это состояние в выводе команды `git status` НЕВИДНО — иначе бы каждый раз `git status` выводила список вообще всех файлов проекта.

**В итоге git status показывает только следующие состояния файлов**:

- `staged` (Changes to be committed);
- `modified` (Changes not staged for commit);
- `untracked` (Untracked files).

#### Подытожим:

- Команда `git status` всегда подскажет, что происходит с файлом: например, он добавлен в список «на коммит» или ещё вообще не отслеживается, или изменён (после коммита).
- `git status` показывает явно следующие состояния файлов: `untracked`, `staged` и `modified`.
- `git status` подсказывает, какие команды можно выполнить, чтобы поменять состояние файла.

<a id=""></a>
## Как исправить коммит?

Иногда в только что выполненном коммите нужно что-то поменять: например, добавить ещё пару файлов или заменить сообщение на более информативное.
В таком случае можно внести правки в уже сделанный коммит с помощью опции `git commit --amend` (от англ. amend — «исправить», «дополнить»). Разберём, как она работает.

<a id=""></a>
### Дополнить последний коммит забытым файлом, например `common.css`, можно так:

```bash
# добавили файл common.css в список на коммит как обычно
$ git add common.css
# но вместо команды commit -m '...'
# будет:
$ git commit --amend --no-edit
$ git log --oneline
8340eb2 Добавить главную страницу
# коммит в истории всё ещё один (но у него новый хеш) 
```

_Обратите внимание_ на опцию `--no-edit`. Она сообщает команде `commit`, что сообщение коммита нужно оставить как было.

Точно так же можно добавить не новый файл, а дополнительные изменения в уже добавленном в коммит файле.

```bash
# ещё раз отредактировали main.html
$ git add main.html # добавили в список на коммит
$ git commit --amend --no-edit 
```

<a id=""></a>
### Изменить сообщение коммита — git commit --amend -m "Новое сообщение"

Допустим, хочется заменить сообщение Добавить главную страницу на Добавить главную страницу и стили. Сделать это можно через `commit --amend` с флагом `-m`.

```bash
$ git commit --amend -m "Добавить главную страницу и стили"
$ git log --oneline
a31fa24 Добавить главную страницу и стили 
```

Хеш коммита снова поменялся, потому что изменились сообщение и время коммита. При этом файлы в коммите остались те же: `main.html` и `common.css`.

**ВНИМАНИЕ!** Если забыть указать у команды `git commit --amend` один из флагов (`--no-edit` или `-m`), Git предложит отредактировать сообщение коммита вручную. Для этого он откроет текстовый редактор, который установлен в системе по умолчанию. Чаще всего это либо GNU nano, либо Vim.

> Учебник по работе с Vim на русском языке запускается командой: `$vimtutor ru`

> <u>Вот как выйти из Vim</u>:
>  - Нажмите клавишу Esc.
> - Наберите последовательность символов :qa!.
> - Нажмите Enter. (редактор должен закрыться)

#### Коротко:

- `--amend` рассчитан на работу с последним коммитом (`HEAD`).
- Дополнить коммит новыми файлами можно с помощью `git commit --amend --no-edit`. Благодаря опции `--no-edit` сообщение к коммиту останется таким, каким и было.
- Изменить сообщение к коммиту позволяет команда `git commit --amend -m "Обновлённое сообщение коммита"`.

<a id=""></a>
## Как откатиться назад, если «всё сломалось»

На разных этапах работы с Git могут происходить похожие ситуации:
 - В список на коммит попал лишний файл (например, временный). Нужно «вынуть» его из списка.
 - Последние несколько коммитов ошибочные: например, сделали не то, что было нужно, или нарушили логику. Хочется «откатить» сразу несколько коммитов, вернуть «как было вчера».
 - Случайно изменился файл, который вообще не должен был меняться. Например, вы открыли не тот файл в редакторе и начали его исправлять.

В этом уроке рассмотрим такие случаи и научим вас «откатывать» нежелательные изменения.

<a id=""></a>
### Выполнить unstage изменений — `git restore --staged <file>`

Допустим, вы создали или изменили какой-то файл и добавили его в список «на коммит» (`staging area`) с помощью `git add`, но потом передумали включать его туда. Убрать файл из `staging` поможет команда `git restore --staged <file>` (от англ. restore — «восстановить»).

> В выводе команды `git status` есть подсказка в скобках: `use "git restore --staged <file>..." to unstage`. 

Чтобы «сбросить» все файлы из staged обратно в `untracked/modified`, можно воспользоваться командой `git restore --staged .`: она сбросит всю текущую папку (`.`).

```bash
# создали ненужный файл
$ touch example.txt 
# добавили его в staged
$ git add example.txt 

# проверили статус
$ git status 
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   example.txt

$ git restore --staged example.txt

# проверили статус
$ git status 

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        example.txt

no changes added to commit (use "git add" and/or "git commit -a")
# файл example.txt из staged вернулся обратно в untracked 
```

<a id=""></a>
## «Откатить» коммит — `git reset --hard <commit hash>`

> Будьте осторожны с командой `git reset --hard`! При удалении коммитов можно потерять что-то нужное.

Иногда нужно «откатить» то, что уже было закоммичено, то есть вернуть состояние репозитория к более раннему. Для этого используют команду `git reset --hard <commit hash>` (от англ. reset  — «сброс», «обнуление» и hard — «суровый»).

```bash
$ git log --oneline # хеш можно найти в истории
7b972f5 (HEAD -> master) style: добавить комментарии, расставить отступы
b576d89 feat: добавить массив Expenses и цикл для добавления трат # вот сюда и вернёмся
4b58962 refactor: разделить analyzeExpenses() на countSum() и saveExpenses()

$ git reset --hard b576d89
# теперь мы на этом коммите
HEAD is now at b576d89 feat: добавить новый метод analyzeExpenses()
```

Теперь коммит `b576d89` стал последним: вся дальнейшая разработка будет вестись от него. Файл также вернулся к тому состоянию, в котором был в момент этого коммита. А коммит `7b972f5` Git просто **удалил**. Это можно проверить, снова запросив лог. Он покажет следующее.

```bash
$ git log --oneline
b576d89 (HEAD -> master) feat: добавить массив Expenses и цикл для добавления трат
4b58962 refactor: разделить analyzeExpenses() на countSum() и saveExpenses() 
```

### «Откатить» изменения, которые не попали ни в `staging`, ни в коммит, — `git restore <file>`

Может быть так, что вы случайно изменили файл, который не планировали. Теперь он отображается в `Changes not staged for commit (modified)`. Чтобы вернуть всё «как было», можно выполнить команду `git restore <file>`.

```bash
# случайно изменили файл example.txt
$ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   example.txt

$ git restore example.txt
$ git status
On branch main
nothing to commit, working tree clean 
```

Изменения в файле «откатятся» до последней версии, которая была сохранена через `git commit` или `git add`.

#### Коротко:

- Команда `git restore --staged <file>` переведёт файл из staged обратно в modified или untracked.
- Команда `git reset --hard <commit hash>` «откатит» историю до коммита с хешем <hash>. Более поздние коммиты потеряются!
- Команда `git restore <file>` «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.


<a id=""></a>
## Просматриваем изменения в файлах

При работе с Git часто нужно узнать, что конкретно изменится или уже изменилось после того или иного коммита. Вот примеры таких ситуаций:

 - Вы собираетесь сделать коммит, но хотите проверить (или перепроверить), какие именно изменения в него попадут.
 - Вчера ваш коллега сделал коммит с сообщением small fix (англ. «небольшое исправление»), после чего тесты проекта начали «падать». Чтобы разобраться в ситуации, нужно посмотреть, что изменилось в этом коммите.

Всё это позволяет делать команда `git diff` (от англ. difference — «отличие», «разница»). Без опций эта команда сравнивает файлы только в состоянии `modified`

```bash
$git diff
```

Чтобы всё-таки просмотреть изменения в `staged`, нужно использовать флаг `--staged`: 

```bash
$ git add teremok.txt 
$ git diff # команда не выведет ничего! 
# команда не выведет изменения! 
$ git diff --staged
```

_Самое важное git diff выводит в конце_:
- красный цвет строки - строка была удалена;
- зелёный цвет строки - строка была добавлена.

Не все консоли умеют выводить цвета, поэтому строки помечаются не только цветом, но и знаком `-` или `+`. Минус — это удалённые строки, плюс — это добавленные.

_Коротко разберём остальные строки вывода команды_:
- Первые две строки (`diff --git a/... b/...` и `index 901da07..ac459e1 100644`) — это низкоуровневая техническая информация. Мы не будем на ней останавливаться.
- Строки `--- a/teremok.txt и +++ b/teremok.txt` говорят, что дальше будет выведен результат сравнения файлов `a/teremok.txt` и `b/teremok.txt` — исходной и текущей версий.
Строка `@@ -1,2 +1,2 @@` сообщает, какие строки файла попали в сравнение. Выражение 1,2 (неважно, с плюсом или с минусом) говорит, что были использованы две строки, начиная с первой. Если бы было, например, написано `+15,7`, это значило бы, что в сравнении участвуют 7 строк, начиная с 15-й.

  Выражение со знаком минус (-1,2) относится к «оригинальной» версии файла (a/teremok.txt), а со знаком плюс (+1,2) — к «изменённой» (b/teremok.txt).

### Сравниваем коммиты

Что бы сравнить коммиты, то нужно команде `git diff` передать хеши обоих коммитов в качестве параметров CMD. Состояние файлов на момент первого переданного коммита будет сравниваться с состоянием файлов на момент второго.

__Порядок аргументов git diff__:

По сути команда `git diff A B` выводит список инструкций: как превратить состояние `A` в состояние `B`. Если поменять `A` и `B` местами (`git diff B A`), то и инструкции будут обратные: как превратить `B` в `A`. При этом все зелёные строки станут красными, и наоборот.


```bash
$ git diff 1c29af6 48fe3dc
```

> Если `48fe3dc` последний (самый свежий) хеш коммита, то вместо него можно использовать `HEAD`: `git diff 1c29af6 HEAD`, потому что `HEAD` указывает на последний коммит.


